## challenge2 -- concurrent matrix multiplication
> This is our team's second challenge!

```
Challenge! The prime sieve is only one neat use of message passing between a 
large number of concurrent programs. Read C. A. R. Hoare, "Communicating 
Sequential Processes," Communications of the ACM 21(8) (August 1978), 666-
667, and implement the matrix multiplication example.
```

### Part 1: Survey - read the paper
我们可以在google scholar上下载到这篇论文pdf版，正版不侵权嗯。本论文的核心就是如何充分利用计算机的并发能力，进行更高效的并行计算；然后论文给出了许多可以使用并行程序解决的经典问题。

传统的存储程序式计算执行的程序都是单个顺序执行的指令序列。随着计算机硬件的发展，多核技术开始出现，如果能够有效利用多核中多个处理单元的计算能力，那么就能够达到比传统单处理器更快速、更可靠、功能更强大、存储容量更大、更为经济的结果。应该说，本文的出发点是硬件的发展推动了软件方面新的算法与程序架构的变革。

如何才能够有效利用多核处理器的机器来完成单个任务呢？如果是不同的任务很好理解，分别放在不同的处理器上运行即可。但是如果同一个程序，这就需要在软件编写方面与其他配套机制的支持互相配合了，肯定会遇到一个任务如何切分，不同部分如何合并等问题。最核心一点就是处理器之间应该有通信与同步机制：在当时普遍使用的通信机制有共享存储方式，然而这种方式比较简单粗暴，很可能引起程序不正确而且硬件设计方面也很困难；同步机制当时主要有信号量、条件临界区、管程、队列等等，但是具体选择哪个来使用或说哪个更好也没有统一的标准。于是这篇paper就想用一种简单的解决方法处理以上所有问题。

#####本文的基本假设大致如下，总结了一下没有很完全：#####
1. 使用Dijkstra's guarded commands，个人理解就是一个形式系统用于抽象描述程序。我没有特别细致地去了解这个形式语言到底是怎么回事，但是能看懂伪代码应该就可以了。
2. 使用parallel command，也是基于Dijkstra的parbegin语法，目测也是用于描述程序的。
3. 进程间的通信，一个进程指定第二个进程作为输出目标，同时第二个进程指定第一个进程作为输入源。类似于网络中建立连接的传输。而且这样的通信机制没有缓冲区，必须等传输双方都准备好才开始通信，如果没准备好就一直等待。
4. 用文中规定写好的程序既可以运行在传统的共享内存的单机上，也可以运行在用网络连接的集群上。没有递归，不同进程之间也不会有共享全局变量。

在文中的3～5节讨论了如何用上述机制来解决实际问题，而且作者也说了：`The reader is invited to skip the examples which do not interest him.` 所以后面的内容我们实际上只用关心我们需要关心的"concurrent matrix multiplication"问题，其余的我会一笔带过然后也没有一个个详细地去读。

第2节介绍了一种形式语言系统，后面的程序都用它表示，然而过于繁杂我只看了一下大概标记都是什么意思就没再看了。3～5节涉及了数据传输处理、数据结构表示与递归、管程和进程调度（有熟悉的有限缓冲区问题、哲学家就餐问题）。第6节的6.1就是lab 4中的primes测试程序的出处，基本思想就是利用多个进程并行来模拟顺序队列的操作。6.2就是我们本次challenge关注的核心内容 -- 并行矩阵乘法。

##### An Iterative Array: Matrix Multiplication #####
问题：给定维数为3的方形矩阵A，输入为行向量IN，一共3个输入流，每个流代表IN的一列(实际上就一个数)。输出也为3个流，分别为IN x A的三个列(其实每列也是一个数)

解决算法：
1. 分成东、南、西、北、中，这五组节点。（颇有中国特色）
2. 北部节点负责提供累加的初始值0。
3. 西部节点是输入流，对应矩阵的三行，标记为x, y, z。（我的理解是源源不断地提供(x0, y0, z0), (x1, y1, z1)这样的三元数对，就能达到不断处理向量和A矩阵相乘的情况）
4. 东部节点实际上是一行的终止，只负责接收西边传来的值，没有其他作用。
5. 南部节点为一列累加运算之后得到的值，就是输出流。
6. 中部节点接收它西边和北边节点传来的值，西边的值乘上该节点的值加上北边传来的值之后，把西边的值原样传给东边，把累加值传给南边。

利用更加规范的表述可能会好一点...
```
想象整个系统为5X5的M矩阵（除去四角共21个节点，利用"a:b"表示[a, b]区间）
WEST: M(1:3, 0)
NORTH: M(0, 1:3)
EAST: M(1:3, 4)
SOUTH: M(4, 1:3)
CENTER: M(1:3, 1:3)
然后WEST与SOUTH是用户提供的输入输出流。
NORTH: 所有节点都为0
EAST: M(i, 3)接受西边(M(i, 2))传来的值，什么都不做。
CENTER: 节点M(i, j)接受西边(M(i, j-1))传来的值x，直接传x给东边(M(i, j+1))。并接收北边M(i-1, j)传来的值sum，计算A(i, j)*x + sum，传给南边(M(i+1, j))
```
然后，就没有然后了...

##### JOS实现上述算法的可行性 #####

* JOS的IPC机制满足论文中提到的："进程间的通信，一个进程指定第二个进程作为输出目标，同时第二个进程指定第一个进程作为输入源。"
* JOS的IPC机制是阻塞式发送和接收，保证了每个进程一次只会处理和另一个进程间的传输。满足了"这样的通信机制没有缓冲区，必须等传输双方都准备好才开始通信，如果没准备好就一直等待。"的条件。
* JOS的IPC机制是在两个进程之间的，和所在CPU没有关系。所以既可以在单处理器的机器上跑，也可以在多处理器的机器上跑。然而JOS并不能支持集群的情况，因为IPC的共享物理页面机制建立在所有处理器共享内存的基础之上。 

#### Part 2: 代码实现

#### Part 3: TEST

#### Part 4: conclusion

